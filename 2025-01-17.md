//代表的なアルゴリズムのソート例
アルゴリズムの性能は以下の二つの指標で評価されます。
①時間計算量：アルゴリズムがデータを処理する際にかかる時間
②空間計算量：アルゴリズムがデータを処理する際に必要な追加メモリ

//バブルソート
隣り合う要素を比較して条件に応じて交換することでデータを整列させるシンプルなアルゴリズム
```python
def bubblesort(arr):
	//配列の長さ
	n=len(arr)

	for i in range(n):
		for j in range(0,n-i-1):
			if arr[j]>arr[j+1]:
				arr[j],arr[j+1]=arr[j+1],arr[j]
```

時間計算量とメリットデメリット
バブルソートの時間計算量は、最悪の場合と平均の場合はO(n^2)で最良の場合位はO(n)です。
すでにほぼ整列されているデータに関しては比較的高速にソートできる。

メリット：実装が非常にシンプルでわかりやすい
デメリット：時間計算量が他と比べて悪い

//選択ソート
データの中から最小の要素を見つけてそれを先頭の要素と交換することでデータを整列させるアルゴリズムのこと

```python
def selection_sort(arr):
	n=len(arr)

	for i in range(n):
		min_index=i
		for j in range(i+1,n):
			if arr[j]<arr[min_index]:
				min_index=j
	arr[i],arr[min_index]=arr[min_index],arr[i]
		
```
データ量が少ない場合や、交換コストが高いデータに対して効率的なソートが求められる場合に適しています。
時間計算量は、最悪の場合、平均の場合、最良の場合全てでO(n^2)です.

メリット：実装がシンプルであることと、交換回数が少ないため交換コストが高いデータに対しては効率的であることです
デメリット：時間計算量が他のソートアルゴリズムと比較して効率が悪いこと

//クイックソート
クイックソートはデータを基準値を使って分割し、基準値より小さい要素と大きい要素に分けることでデータを整列させるアルゴリズムです。
このプロセスを再帰的に繰り返し行い、データ全体を整列させます。
最悪の場合はO（n^2）平均の場合はO(nlogn)、最良の場合はO(nlogn)です


```python
def partition(arr,low,high):
	pivot=arr[high]
	i=low-1

	for j in range(low,high):
		if arr[j]<=pivot:
			i+=1
			arr[i],arr[j]=arr[j],arr[i]
	arr[i+1],arr[high]=arr[high],arr[i+1]
	return i+1
```

//マージソート
安定ソートであり、最悪の場合でもO(n log n)の時間計算量
大量のデータや順序が重要なデータに適している
ただし、空間計算量が大きい